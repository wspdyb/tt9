import java.nio.ByteBuffer
import java.nio.charset.StandardCharsets


ext.getDictionaryProperties = { dictionariesDir, sizesDir ->
	fileTree(dir: dictionariesDir).getFiles().parallelStream().forEach {dictionary ->
		def hash = dictionary.exists() ? dictionary.text.digest("SHA-1") : ""
		def revision = dictionary.exists() ? exec("git log --pretty=tformat:%H -n 1 ${dictionary}") : ""
		def size = dictionary.exists() ? dictionary.length() : 0
		def words = dictionary.exists() ? dictionary.text.split("\n").length : 0

		new File(sizesDir, "${dictionary.getName()}.props.yml").text = "hash: ${hash}\nrevision: ${revision}\nsize: ${size}\nwords: ${words}"
	}
}


ext.convertDictionaries = { definitionsInputDir, dictionariesInputDir, dictionariesOutputDir ->
	int errorCount = 0

	def errorStream = fileTree(dir: definitionsInputDir).getFiles().parallelStream().map { definition ->
		def (alphabet, sounds, locale, dictionaryFile, langFileErrorCount, langFileErrorMsg) = parseLanguageFile(definition, dictionariesInputDir)
		errorCount += langFileErrorCount
		if (!langFileErrorMsg.isEmpty()) {
			return langFileErrorMsg
		}

		def (conversionErrorCount, conversionErrorMessages) = convertDictionary(dictionaryFile, dictionariesOutputDir, DICTIONARY_OUTPUT_EXTENSION, alphabet, sounds, locale, MAX_ERRORS, CSV_DELIMITER, MAX_WORD_FREQUENCY, DICTIONARY_COMPRESSION)
		errorCount += conversionErrorCount
		if (!conversionErrorMessages.isEmpty()) {
			return conversionErrorMessages
		}

		return ""
	}

	String errorsMsg = errorStream.reduce("", String::concat)
	if (errorsMsg) {
		throw new GradleException(errorsMsg)
	}
}


static def convertDictionary(File dictionaryFile, String dictionariesOutputDir, String outputDictionaryExtension, String alphabet, HashMap<String, String> sounds, Locale locale, int maxErrors, String csvDelimiter, int maxWordFrequency, boolean isCompressionEnabled) {
	final int MAX_SORTING_ERRORS = Math.ceil(maxErrors / 10)
	final VALID_CHARS = alphabet.toUpperCase(locale) == alphabet ? "^[${alphabet}\\-\\.']+\$" : "^[${alphabet}${alphabet.toUpperCase(locale)}\\-\\.']+\$"

	int errorCount = 0
	String errorMsg = ''
	Set<String> uniqueWords = new HashSet<>()

	List<String> fileContents = dictionaryFile.readLines()
	LinkedHashMap<String, ArrayList<String>> outputDictionary = new LinkedHashMap<>()

	for (int lineNumber = 1, previousWordLength = 0, sortingErrorCount = 0; lineNumber <= fileContents.size() && errorCount < maxErrors; lineNumber++) {
		String line = fileContents.get(lineNumber - 1)

		String whiteSpaceError = validateNoWhitespace(line, lineNumber)
		if (whiteSpaceError) {
			errorCount++
			errorMsg += whiteSpaceError
		}

		def (word, transcription, frequency) = getLineData(line, csvDelimiter)

		String frequencyError = validateFrequency(frequency, maxWordFrequency, dictionaryFile.name, lineNumber)
		if (frequencyError) {
			errorCount++
			errorMsg += frequencyError
		}

		def (wordErrorCount, wordErrors) = validateWord(word, VALID_CHARS, sounds.isEmpty(), lineNumber, "Dictionary '${dictionaryFile.name}' is invalid")
		if (wordErrorCount > 0) {
			errorCount += wordErrorCount
			errorMsg += wordErrors
		}

		if (uniqueWords.contains(word)) {
			errorCount++
			errorMsg += "Dictionary '${dictionaryFile.name}' is invalid. Found duplicate word: '${word}' on line ${lineNumber}. Remove all duplicates.\n"
		} else {
			uniqueWords.add(word)
		}

		String sortingError = validateWordOrder(word, previousWordLength, errorCount, MAX_SORTING_ERRORS, dictionaryFile.name, lineNumber)
		if (sortingError) {
			errorCount++
			sortingErrorCount++
			errorMsg += sortingError
		}
		previousWordLength = word.length()

		String digitSequence = ""
		try {
			def transcribedWord = transcription.isEmpty() ? word : transcription
			digitSequence = wordToDigitSequence(locale, transcribedWord, sounds, !transcription.isEmpty())
		} catch (IllegalArgumentException e) {
			errorCount++
			errorMsg += "Dictionary '${dictionaryFile.name}' is invalid. Failed generating digit sequence for word '${word}' on line ${lineNumber}. ${e.message}\n"
		}

		if (errorCount == 0) {
			if (!outputDictionary.containsKey(digitSequence)) {
				outputDictionary.put(digitSequence, new ArrayList<>())
			}
			outputDictionary.get(digitSequence).add(word)
		}
	}

	new File(dictionariesOutputDir, dictionaryFile.name + "." + outputDictionaryExtension).withOutputStream { out ->
		outputDictionary.each { digitSequence, words ->
			out.write(isCompressionEnabled ? compressLine(digitSequence, words) : convertLine(digitSequence, words))
		}

	}

	return [errorCount, errorMsg]
}


//////////////////// PARSING ////////////////////

static def getLineData(String line, String delimiter) {
	String[] parts = line.split(delimiter, 2)
	String word = parts[0]
	String transcription = parts.length > 1 && parts[1] =~ "^[a-zA-Z]+\$" ? parts[1] : ""

	int frequency
	try {
		int partsElement = transcription.isEmpty() ? 1 : 2
		frequency = (parts.length > partsElement ? parts[partsElement] : "0") as int
	} catch (Exception ignored) {
		frequency = -1
	}

	return [word, transcription, frequency]
}


static def wordToDigitSequence(Locale locale, String word, HashMap<String, String> sounds, boolean isTranscribed) {
	String sequence = ""

	final String normalizedWord = isTranscribed ? word : word.toUpperCase(locale)
	String currentSound = ""

	for (int i = 0, end = normalizedWord.length() - 1; i <= end; i++) {
		char currentChar = normalizedWord.charAt(i)
		char nextChar = i < end ? normalizedWord.charAt(i + 1) : 0
		int nextCharType = Character.getType(nextChar)

		currentSound += currentChar

		// charAt(i) returns "ΐ" as three separate characters, but they must be treated as one.
		if (
			locale.getLanguage() == "el"
			&& (nextCharType == Character.NON_SPACING_MARK || nextCharType == Character.ENCLOSING_MARK || nextCharType == Character.COMBINING_SPACING_MARK)
		) {
			continue
		}

		if (!isTranscribed || i == end || Character.isUpperCase(nextChar)) {
			if (!sounds.containsKey(currentSound)) {
				throw new IllegalArgumentException("Sound or layout entry '${currentSound}' does not belong to the language sound list: ${sounds}.")
			} else {
				sequence += sounds.get(currentSound)
				currentSound = ""
			}
		}
	}

	if (sequence.isEmpty()) {
		throw new IllegalArgumentException("The word does not contain any valid sounds.")
	}

	return sequence
}

//////////////////// VALIDATION ////////////////////

static def validateNoWhitespace(String line, int lineNumber) {
	if (line == "") {
		return "There is no word on line ${lineNumber}. Remove all empty lines.\n"
	} else if (line.contains(" ")) {
		return "Found space on line ${lineNumber}. Make sure each word is on a new line. Phrases are not allowed.\n"
	}

	return ''
}


static def validateFrequency(int frequency, int maxFrequency, String dictionaryFileName, int lineNumber) {
	if (frequency < 0 || frequency > maxFrequency) {
		return "Dictionary '${dictionaryFileName}' is invalid. Found out-of-range word frequency: '${frequency}' on line ${lineNumber}. Frequency must be an integer between 0 and ${maxFrequency}.\n"
	}

	return ''
}


static def validateWord(String word, String validCharacters, boolean isAlphabetLanguage, int lineNumber, String errorMsgPrefix) {
	int errorCount = 0
	def errors = ''

	if (word.matches("(\\d.+?|.+?\\d|\\d)")) {
		errorCount++
		errors += "${errorMsgPrefix}. Found numbers on line ${lineNumber}. Remove all numbers.\n"
	}

	if (word.matches("^\\P{L}+\$")) {
		errorCount++
		errors += "${errorMsgPrefix}. Found a garbage word: '${word}' on line ${lineNumber}.\n"
	}

	if (isAlphabetLanguage && word.matches("^(.|\\p{L}\\p{M}?)\$")) {
		errorCount++
		errors += "${errorMsgPrefix}. Found a single letter: '${word}' on line ${lineNumber}. Only uppercase single letters are allowed. The rest of the alphabet will be added automatically.\n"
	}

	if (errorCount == 0 && isAlphabetLanguage && !word.matches(validCharacters)) {
		errorCount++
		errors += "${errorMsgPrefix}. Word '${word}' on line ${lineNumber} contains characters outside of the defined alphabet: $validCharacters.\n"
	}

	return [errorCount, errors]
}


static validateWordOrder(String word, int previousWordLength, int sortingErrorCount, int maxSortingErrors, String dictionaryFileName, int lineNumber) {
	if (word.length() >= previousWordLength || sortingErrorCount > maxSortingErrors) {
		return ""
	} else if (sortingErrorCount == maxSortingErrors) {
		return "Too many sorting errors in '${dictionaryFileName}'. Disabling sorting check until the end of the file.\n"
	} else {
		return "Dictionary '${dictionaryFileName}' is not sorted. Word: '${word}' on line ${lineNumber} is shorter than the previous one. Ensure all words are sorted by length and sequence.\n"
	}
}

//////////////////// COMPRESSION ////////////////////

/**
 * Compresses a digit sequence and all its corresponding words into a single byte array.
 * The output format is as follows:
 * - digit sequence/word length (1 byte)
 * - digit sequence numbers packed into nibbles (4 bits per digit) = (length / 2) bytes
 * - concatenated UTF-8 bytes of all words
 */
static byte[] compressLine(String digitSequence, List<String> words) {
	// character count of each word, same as digit sequence length
	int wordLength = digitSequence.length()

	// Step 1: Create ByteBuffer with capacity to hold all data
	def digitBytes = (int) Math.ceil((wordLength + 1) / 2)  // Bytes needed to store nibbles (4-bit)
	def utf8Bytes = words.join('').getBytes(StandardCharsets.UTF_8) // Concatenated UTF-8 bytes
	def buffer = ByteBuffer.allocate(1 + digitBytes + utf8Bytes.length)

	// Step 2: Write the length as the first byte
	buffer.put((byte) wordLength)

	// Step 3: Pack the digit sequence into nibbles (1 digit = 4 bits, 2 digits = 1 byte)
	def packedDigits = packDigitSequence(digitSequence, digitBytes)
	buffer.put(packedDigits)

	// Step 4: Concatenate the words
	buffer.put(utf8Bytes)

	return buffer.array()
}


static byte[] packDigitSequence(String digits, int length) {
	ByteBuffer packedBuffer = ByteBuffer.allocate(length)

	for (int i = 0; i < digits.length(); i += 2) {
		int highNibble = Character.digit(digits[i] as char, 10) << 4
		int lowNibble = (i + 1 < digits.length()) ? Character.digit(digits[i + 1] as char, 10) : 0
		packedBuffer.put((byte) (highNibble | lowNibble))
	}

	return packedBuffer.array()
}


static byte[] convertLine(String digitSequence, List<String> words) {
	return (digitSequence + words.join(" ") + "\n").getBytes(StandardCharsets.UTF_8)
}
