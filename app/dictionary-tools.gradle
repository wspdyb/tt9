ext.getDictionaryProperties = { dictionariesDir, sizesDir ->
	fileTree(dir: dictionariesDir).getFiles().parallelStream().forEach {dictionary ->
		def hash = dictionary.exists() ? dictionary.text.digest("SHA-1") : ""
		def revision = dictionary.exists() ? exec("git log --pretty=tformat:%H -n 1 ${dictionary}") : ""
		def size = dictionary.exists() ? dictionary.length() : 0
		def words = dictionary.exists() ? dictionary.text.split("\n").length : 0

		new File(sizesDir, "${dictionary.getName()}.props.yml").text = "hash: ${hash}\nrevision: ${revision}\nsize: ${size}\nwords: ${words}"
	}
}


ext.convertDictionaries = { definitionsInputDir, dictionariesInputDir, dictionariesOutputDir ->
	int errorCount = 0

	def errorStream = fileTree(dir: definitionsInputDir).getFiles().parallelStream().map { definition ->
		def (alphabet, sounds, locale, dictionaryFile, langFileErrorCount, langFileErrorMsg) = parseLanguageFile(definition, dictionariesInputDir)
		errorCount += langFileErrorCount
		if (!langFileErrorMsg.isEmpty()) {
			return langFileErrorMsg
		}

		def (conversionErrorCount, conversionErrorMessages) = convertDictionary(dictionaryFile, alphabet, sounds, locale, MAX_ERRORS, CSV_DELIMITER, MAX_WORD_FREQUENCY)
		errorCount += conversionErrorCount
		if (!conversionErrorMessages.isEmpty()) {
			return conversionErrorMessages
		}

		return ""
	}

	String errorsMsg = errorStream.reduce("", String::concat)
	if (errorsMsg) {
		throw new GradleException(errorsMsg)
	}
}


static def convertDictionary(File dictionaryFile, String alphabet, HashMap<String, String> sounds, Locale locale, int maxErrors, String csvDelimiter, int maxWordFrequency) {
	final VALID_CHARS = alphabet.toUpperCase(locale) == alphabet ? "^[${alphabet}\\-\\.']+\$" : "^[${alphabet}${alphabet.toUpperCase(locale)}\\-\\.']+\$"

	int errorCount = 0
	String allErrors = ''
	List<String> dictionaryContents = dictionaryFile.readLines()

	for (int lineNumber = 1, previousWordLength = 0, fileErrors = 0; lineNumber <= dictionaryContents.size() && errorCount < maxErrors; lineNumber++) {
		String line = dictionaryContents.get(lineNumber - 1)

		String whiteSpaceError = validateNoWhitespace(line, lineNumber)
		if (whiteSpaceError) {
			fileErrors++
			allErrors += whiteSpaceError
		}

		def (word, frequency) = getLineData(line, csvDelimiter)

		String frequencyError = validateFrequency(frequency, maxWordFrequency, dictionaryFile.name, lineNumber)
		if (frequencyError) {
			fileErrors++
			allErrors += frequencyError
		}

		def (wordErrorCount, wordErrors) = validateWord(word, lineNumber, VALID_CHARS, "Dictionary '${dictionaryFile.name}' is invalid")
		if (wordErrorCount > 0) {
			fileErrors += wordErrorCount
			allErrors += wordErrors
		}

		// @todo: validate no repeating words
		// @todo: validate words are sorted

		if (fileErrors > 0) {
			errorCount += fileErrors
		} else {
			// @todo: transform the "word", "frequency" and "sounds" and write them to a new file
		}

	}

	return [errorCount, allErrors]
}


static def validateNoWhitespace(String line, int lineNumber) {
	if (line == "") {
		return "There is no word on line ${lineNumber}. Remove all empty lines.\n"
	} else if (line.contains(" ")) {
		return "Found space on line ${lineNumber}. Make sure each word is on a new line. Phrases are not allowed.\n"
	}

	return ''
}


static def getLineData(String line, String delimiter) {
	String[] parts = line.split(delimiter, 2)
	String word = parts[0]
	int frequency
	try {
		frequency = (parts.length > 1 ? parts[1] : "0") as int
	} catch (Exception ignored) {
		frequency = -1
	}

	return [word, frequency]
}


static def validateFrequency(int frequency, int maxFrequency, String dictionaryFileName, int lineNumber) {
	if (frequency < 0 || frequency > maxFrequency) {
		return "Dictionary '${dictionaryFileName}' is invalid. Found out-of-range word frequency: '${frequency}' on line ${lineNumber}. Frequency must be an integer between 0 and ${maxFrequency}.\n"
	}

	return ''
}


static def validateWord(String word, int lineNumber, String validCharacters, String errorMsgPrefix) {
	int errorCount = 0
	def errors = ''

	if (word.matches("(\\d.+?|.+?\\d|\\d)")) {
		errorCount++
		errors += "${errorMsgPrefix}. Found numbers on line ${lineNumber}. Remove all numbers.\n"
	}

	if (word.matches("^\\P{L}+\$")) {
		errorCount++
		errors += "${errorMsgPrefix}. Found a garbage word: '${word}' on line ${lineNumber}.\n"
	}

	if (word.matches("^(.|\\p{L}\\p{M}?)\$")) {
		errorCount++
		errors += "${errorMsgPrefix}. Found a single letter: '${word}' on line ${lineNumber}. Only uppercase single letters are allowed. The rest of the alphabet will be added automatically.\n"
	}

	if (errorCount == 0 && !word.matches(validCharacters)) {
		errorCount++
		errors += "${errorMsgPrefix}. Word '${word}' on line ${lineNumber} contains characters outside of the defined alphabet: $validCharacters.\n"
	}

	return [errorCount, errors]
}