apply from: 'dictionary-validation.gradle'

ext.getDictionaryProperties = { dictionariesDir, sizesDir ->
	fileTree(dir: dictionariesDir).getFiles().parallelStream().forEach {dictionary ->
		def hash = dictionary.exists() ? dictionary.text.digest("SHA-1") : ""
		def revision = dictionary.exists() ? exec("git log --pretty=tformat:%H -n 1 ${dictionary}") : ""
		def size = dictionary.exists() ? dictionary.length() : 0
		def words = dictionary.exists() ? dictionary.text.split("\n").length : 0

		new File(sizesDir, "${dictionary.getName()}.props.yml").text = "hash: ${hash}\nrevision: ${revision}\nsize: ${size}\nwords: ${words}"
	}
}


ext.convertDictionaries = { definitionsInputDir, dictionariesInputDir, dictionariesOutputDir ->
	int errorCount = 0

	def errorStream = fileTree(dir: definitionsInputDir).getFiles().parallelStream().map { definition ->
		def (alphabet, sounds, locale, dictionaryFile, langFileErrorCount, langFileErrorMsg) = parseLanguageFile(definition, dictionariesInputDir)
		errorCount += langFileErrorCount
		if (!langFileErrorMsg.isEmpty()) {
			return langFileErrorMsg
		}

		def (conversionErrorCount, conversionErrorMessages) = convertDictionary(dictionaryFile, alphabet, sounds, locale, MAX_ERRORS, CSV_DELIMITER, MAX_WORD_FREQUENCY)
		errorCount += conversionErrorCount
		if (!conversionErrorMessages.isEmpty()) {
			return conversionErrorMessages
		}

		return ""
	}

	String errorsMsg = errorStream.reduce("", String::concat)
	if (errorsMsg) {
		throw new GradleException(errorsMsg)
	}
}


static def convertDictionary(File dictionaryFile, String alphabet, HashMap<String, String> sounds, Locale locale, int maxErrors, String csvDelimiter, int maxWordFrequency) {
	final int MAX_SORTING_ERRORS = Math.ceil(maxErrors / 10)
	final VALID_CHARS = alphabet.toUpperCase(locale) == alphabet ? "^[${alphabet}\\-\\.']+\$" : "^[${alphabet}${alphabet.toUpperCase(locale)}\\-\\.']+\$"

	int errorCount = 0
	String errorMsg = ''
	Set<String> uniqueWords = new HashSet<>()

	List<String> fileContents = dictionaryFile.readLines()
	for (int lineNumber = 1, previousWordLength = 0, sortingErrorCount = 0; lineNumber <= fileContents.size() && errorCount < maxErrors; lineNumber++) {
		String line = fileContents.get(lineNumber - 1)

		String whiteSpaceError = validateNoWhitespace(line, lineNumber)
		if (whiteSpaceError) {
			errorCount++
			errorMsg += whiteSpaceError
		}

		def (word, frequency) = getLineData(line, csvDelimiter)

		String frequencyError = validateFrequency(frequency, maxWordFrequency, dictionaryFile.name, lineNumber)
		if (frequencyError) {
			errorCount++
			errorMsg += frequencyError
		}

		def (wordErrorCount, wordErrors) = validateWord(word, lineNumber, VALID_CHARS, "Dictionary '${dictionaryFile.name}' is invalid")
		if (wordErrorCount > 0) {
			errorCount += wordErrorCount
			errorMsg += wordErrors
		}

		if (uniqueWords.contains(word)) {
			errorCount++
			errorMsg += "Dictionary '${dictionaryFile.name}' is invalid. Found duplicate word: '${word}' on line ${lineNumber}. Remove all duplicates.\n"
		} else {
			uniqueWords.add(word)
		}

		String sortingError = validateWordOrder(word, previousWordLength, errorCount, MAX_SORTING_ERRORS, dictionaryFile.name, lineNumber)
		if (sortingError) {
			errorCount++
			sortingErrorCount++
			errorMsg += sortingError
		}
		previousWordLength = word.length()

		if (errorCount == 0) {
			// @todo: transform the "word", "frequency" and "sounds" and write them to a new file
		}
	}

	return [errorCount, errorMsg]
}


static def validateNoWhitespace(String line, int lineNumber) {
	if (line == "") {
		return "There is no word on line ${lineNumber}. Remove all empty lines.\n"
	} else if (line.contains(" ")) {
		return "Found space on line ${lineNumber}. Make sure each word is on a new line. Phrases are not allowed.\n"
	}

	return ''
}


static def getLineData(String line, String delimiter) {
	String[] parts = line.split(delimiter, 2)
	String word = parts[0]
	int frequency
	try {
		frequency = (parts.length > 1 ? parts[1] : "0") as int
	} catch (Exception ignored) {
		frequency = -1
	}

	return [word, frequency]
}


static def validateFrequency(int frequency, int maxFrequency, String dictionaryFileName, int lineNumber) {
	if (frequency < 0 || frequency > maxFrequency) {
		return "Dictionary '${dictionaryFileName}' is invalid. Found out-of-range word frequency: '${frequency}' on line ${lineNumber}. Frequency must be an integer between 0 and ${maxFrequency}.\n"
	}

	return ''
}


static def validateWord(String word, int lineNumber, String validCharacters, String errorMsgPrefix) {
	int errorCount = 0
	def errors = ''

	if (word.matches("(\\d.+?|.+?\\d|\\d)")) {
		errorCount++
		errors += "${errorMsgPrefix}. Found numbers on line ${lineNumber}. Remove all numbers.\n"
	}

	if (word.matches("^\\P{L}+\$")) {
		errorCount++
		errors += "${errorMsgPrefix}. Found a garbage word: '${word}' on line ${lineNumber}.\n"
	}

	if (word.matches("^(.|\\p{L}\\p{M}?)\$")) {
		errorCount++
		errors += "${errorMsgPrefix}. Found a single letter: '${word}' on line ${lineNumber}. Only uppercase single letters are allowed. The rest of the alphabet will be added automatically.\n"
	}

	if (errorCount == 0 && !word.matches(validCharacters)) {
		errorCount++
		errors += "${errorMsgPrefix}. Word '${word}' on line ${lineNumber} contains characters outside of the defined alphabet: $validCharacters.\n"
	}

	return [errorCount, errors]
}


static validateWordOrder(String word, int previousWordLength, int sortingErrorCount, int maxSortingErrors, String dictionaryFileName, int lineNumber) {
	if (word.length() >= previousWordLength || sortingErrorCount > maxSortingErrors) {
		return ""
	} else if (sortingErrorCount == maxSortingErrors) {
		return "Too many sorting errors in '${dictionaryFileName}'. Disabling sorting check until the end of the file.\n"
	} else {
		return "Dictionary '${dictionaryFileName}' is not sorted. Word: '${word}' on line ${lineNumber} is shorter than the previous one. Ensure all words are sorted by length and sequence.\n"
	}
}